=pod

=head1 NAME

OSSL_HTTP_get_asn1,
OSSL_HTTP_post_asn1,
OSSL_HTTP_proxy_connect,
OSSL_HTTP_parse_url
- http client functions

=head1 SYNOPSIS

 #include <openssl/http.h>

 typedef BIO *(*HTTP_bio_cb_t) (BIO *bio, void *arg, int connect, int detail);
 ASN1_VALUE *OSSL_HTTP_get_asn1(const char *url,
                                const char *proxy, const char *proxy_port,
                                HTTP_bio_cb_t bio_update_fn, void *arg,
                                const STACK_OF(CONF_VALUE) *headers,
                                int maxline, unsigned long max_resp_len,
                                long timeout, const ASN1_ITEM *it);
 ASN1_VALUE *OSSL_HTTP_post_asn1(const char *server, const char *port,
                                 const char *path,
                                 const char *proxy, const char *proxy_port,
                                 HTTP_bio_cb_t bio_update_fn, void *arg,
                                 const STACK_OF(CONF_VALUE) *headers,
                                 const char *content_type,
                                 ASN1_VALUE *req, const ASN1_ITEM *req_it,
                                 int maxline, unsigned long max_resp_len,
                                 long timeout, const ASN1_ITEM *rsp_it);
 int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
                             const char *proxyuser, const char *proxypass,
                             long timeout, BIO *bio_err, const char *prog);
 int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
                         char **ppath, int *pssl);

=head1 DESCRIPTION

OSSL_HTTP_get_asn1() uses HTTP GET to obtain an ASN.1-encoded value
(e.g., an X.509 certificate) with the expected structure specified by B<it>
(e.g., I<ASN1_ITEM_rptr(X509)>) from the given B<url>
optionally via B<proxy> and B<port_port>.

OSSL_HTTP_post_asn1() uses the HTTP POST method to send a request B<req>
with the ASN.1 structure defined in B<req_it> and the given B<content_type>
to the given B<server> and optional B<port> and B<path>,
optionally via B<proxy> and B<port>.
The optional list B<headers> may contain additional custom HTTP header lines.
The B<maxline> parameter specifies the response header maximum line length,
where 0 indicates the default value, which currently is 4k.
The B<max_resp_len> parameter specifies the maximum response length,
where 0 indicates the default value, which currently is 100k.
The expected structure of the response is specified by B<rsp_it>.

Both function have the following parameters in common.

If the B<timeout> parameter is > 0 this indicates the maximum number of seconds
to wait until the transfer is complete. A value of 0 enables waiting
indefinitely, while a value < 0 immediately leads to a timeout condition.

The optional parameter B<bio_update_fn> with its optional argument B<arg>
may be used to modify the connection BIO used internally. B<bio_update_fn>
is a BIO connect/disconnect callback function with the prototype

   typedef BIO *(*HTTP_bio_cb_t) (BIO *bio, void *arg, int connect, int detail);

The callback may modify the HTTP BIO provided in the B<bio> argument,
whereby it may make use of a custom defined argument B<arg>,
which may for instance refer to an I<SSL_CTX> structure.
During connection establishment, just after calling BIO_connect_retry(),
the function is invoked with the B<connect> argument being 1 and the B<detail>
argument being 1 if HTTPS is requested, i.e., SSL/TLS should be enabled. On
disconnect B<connect> is 0 and B<detail> is 1 in case no error occurred, else 0.
For instance, on connect the function may prepend a TLS BIO to implement HTTPS;
after disconnect it may do some diagnostic output and/or specific cleanup.
The function should return NULL to indicate failure. Here is an example:

static BIO *tls_http_cb(BIO *cbio, void *arg, int connect, int detail)
{
    SSL_CTX *ctx = (SSL_CTX *)arg;

    if (connect && detail) { /* connecting with TLS */
        BIO *sbio = BIO_new_ssl(ctx, 1);
        cbio = sbio != NULL ? BIO_push(sbio, cbio) : NULL;
    } else if (!connect && !detail) { /* disconnecting after error */
        const char *hint = tls_error_hint(detail);
        if (hint != NULL)
            ERR_add_error_data(1, hint);
    }
    return cbio;
}

After disconnect the modified BIO will be deallocated using BIO_free_all().

OSSL_HTTP_proxy_connect() promotes the given connection BIO B<bio>
via the CONNECT method for proxying to B<server> and B<port> with
optional proxy client credentials B<proxyuser> and B<proxypass>.
The B<timeout> parameter is used as described above.
For cases where this function is called by an appplication, the B<bio_err>
and B<prog> are used unless NULL to print additional diagnostic information
in a user-oriented way.
This function may be used by the above BIO connect callback function to
set up an SSL/TLS connection via an HTTP proxy.

OSSL_HTTP_parse_url() parses its input string B<url> as a URL and splits it up
into host, port and path components and a flag whether it begins with 'https'.
As far as the result pointer arguments are not NULL it assigns via
them copies of the respective input string components. The strings returned
this way must be deallocated by the caller using <OPENSSL_free(3)>
unless they are NULL, which is their default value on error.
The host component may be a DNS name or an IPv4 or an IPv6 address. The port
component may be absent and defaults to 80 for http, else 443 for https.

=head1 RETURN VALUES

OSSL_HTTP_get_asn1() and OSSL_HTTP_post_asn1() return on success the
data retrieved via HTTP, else NULL.
Error conditions include connection/transfer timeout, parse errors, etc.

OSSL_HTTP_proxy_connect() and OSSL_HTTP_parse_url()
return 1 on success, 0 on error.

=head1 HISTORY

OSSL_HTTP_get_asn1(), OSSL_HTTP_post_asn1(), OSSL_HTTP_proxy_connect(),
and OSSL_HTTP_parse_url() were added in OpenSSL 3.0.

=head1 COPYRIGHT

Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
